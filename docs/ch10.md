# Streams
## Stream of Primitive
### DoubleStream
Return an `OptionalDouble`:
- `max()`
- `min()`
- `average()`
Do not return an `OptionalDouble`
- `count()`: return a long
- `sum()`: return a double
[DoubleStream](../src/main/java/org/enricogiurin/ocp17/book/ch10/primitivestream/UsageOfDoubleStream.java)

### DoubleSummaryStatistics
```java
DoubleSummaryStatistics summaryStatistics = DoubleStream.iterate(1D, n -> n + n / 2)
    .limit(10L)
    .summaryStatistics();
double average = summaryStatistics.getAverage();
```
[DoubleSummaryStatistics](../src/main/java/org/enricogiurin/ocp17/book/ch10/primitivestream/UsageOfDoubleSummaryStatistics.java)
## Optional
### Optional for primitives
- `OptionalInt` > `getAsInt()`
- `OptionalLong` -> `getAsLong()`
- `OptionalDouble` -> `getAsDouble() `
### Optional Exception
If a value is present, returns the value, otherwise throws `NoSuchElementException`.
```java
opt.orElseThrow();
```
## Infinite Stream
```java
Stream.generate(() -> "1");
Stream.iterate(1, x -> x++);
```
## Intermediate Operations
### sorted
```java
//default natural order
stream
    .sorted()
    .forEach(System.out::println);

//order set by comparator
stream
    .sorted((c1,c2)->c1-c2)
    .forEach(System.out::println);
```
## Terminal Operations
### FindAny() / findFirst()
```java
public Optional<T> findAny()
public Optional<T> findFirst()
```
The `findFirst()` method **always** returns the first element on an ordered stream, regardless if it is serial or parallel,
### Matching
```java
public boolean anyMatch(Predicate <? super T> predicate)
public boolean allMatch(Predicate <? super T> predicate)
public boolean noneMatch(Predicate <? super T> predicate)
```
### min
For `Stream<T>`
```java
Stream<String> stream = Stream.of("a", "ab", "abc");
//min() requires a Comparator
Optional<String> min = stream.min((o1, o2) -> o1.length() - o2.length());
```
For `IntStream`
```java
IntStream rangeClosed = IntStream.rangeClosed(0, 9);
OptionalInt optional = rangeClosed.min();
```
## Reduce
```java
public T reduce(T identity, BinaryOperator<T> accumulator)
 
public Optional<T> reduce(BinaryOperator<T> accumulator)
 
public <U> U reduce(U identity,
   BiFunction<U,? super T,U> accumulator,
   BinaryOperator<U> combiner)
```
## Collectors
### PartitioningBy
```java
Map<Boolean, List<String>> map = ohMy.collect(
   Collectors.partitioningBy(s -> s.length() <= 5));
```
It requires a `Predicate<T>`

### GroupingBy
```java
Map<Integer, List<String>> map = ohMy.collect(
   Collectors.groupingBy(String::length));
```
It requires a `Function<T,V>`



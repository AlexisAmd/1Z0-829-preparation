# Lambdas and Functional Interfaces

## Object Methods

If a functional interface includes an abstract method with
the same signature as a public method found in `Object`, those methods do not count toward the single
abstract method test.

## Lambda
**I can't assign a lambda to a var!!!!**
```java
//  Error:
//  cannot infer type for local variable lambda
//  (lambda expression needs an explicit target-type)
var lambda=s->s+2;
```

### Lambda boxing
```java
//does not compile
Function<Integer, Boolean> function = (int i) -> {return false;}
```
The type is Integer in the Function and int in the lambda.

### Lambda and variables effective final
Lambdas require **local variables** and **method parameters** to be effectively final to use them.
Instance and static variables can be used regardless of whether they are effectively final.
[LambdaEffectiveFinal](../src/main/java/org/enricogiurin/ocp17/book/ch8/LambdaEffectiveFinal.java)
#### Rules
When using lambda expressions that access instance variables, local variables, or parameters:
* local variables **must be** effective final
* parameters **must be** effective final
* instance variables **are not subject** to the effective final constraint.

### Deferred execution
Deferred execution means the lambda expression is not evaluated until runtime, but it is compiled.  
In the context of lambdas in Java, deferred execution refers to the delayed execution of the code encapsulated within the lambda expression.

## Method Reference
The same Method Reference, `ArrayList::new`, can be applied to different FunctionalInterface:
* `Function<Integer, List<Integer>>`
* `Supplier<List<Integer>> supplier`
```java
Function<Integer, List<Integer>> create = n->new ArrayList<>(n);
Function<Integer, List<Integer>> createMR = ArrayList::new;

List<Integer> list = createMR.apply(10);

//but we can also avoid passing the initial capacity, then in this case it's a Supplier
Supplier<List<Integer>> supplier = ArrayList::new;
```
## Function
### Compose
```java
//javadoc
default<V> Function<V, R> compose(Function<? super V,?extends T>before)
```

_Returns a composed function that first applies the **before** function to its input, and then
applies this function to the result.
If evaluation of either function throws an exception, it is relayed to the caller of the composed
function._

```java
Function<Integer, Integer> after=a->a+4;
Function<Integer, Integer> before=a->a*3;
Function<Integer, Integer> compose=after.compose(before);
System.out.print(compose.apply(2));  // (2*3) + 4 = 10
```
## Functional Interfaces

### Main Functional Interfaces (generated by CGPT)
| Functional Interface | Method                   |
|----------------------|--------------------------|
| `Predicate<T>`       | `boolean test(T t)`      |
| `Consumer<T>`        | `void accept(T t)`       |
| `Function<T, R>`     | `R apply(T t)`           |
| `Supplier<T>`        | `T get()`                |
| `UnaryOperator<T>`    | `T apply(T t)`           |
| `BinaryOperator<T>`   | `T apply(T t1, T t2)`    |
| `BiPredicate<T, U>`   | `boolean test(T t, U u)` |
| `BiConsumer<T, U>`    | `void accept(T t, U u)`  |
| `BiFunction<T, U, R>` | `R apply(T t, U u)`      |

### BooleanSupplier
```java
BooleanSupplier bs = () -> Math.random() >= 0.5;
boolean result = bs.bs.getAsBoolean();
```
It's _getAsBoolean()_ **NOT** get()
### IntUnaryOperator
Note: this FI does not have generics!
```java
//note that this FI does not have generics
IntUnaryOperator intUnaryOperator = n -> n * 2;
int result = intUnaryOperator.applyAsInt(10);
System.out.println(result);
```